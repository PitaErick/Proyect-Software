<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/Proyect-Software/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/Proyect-Software/" rel="alternate" type="text/html" /><updated>2020-08-18T05:55:32-05:00</updated><id>http://localhost:4000/Proyect-Software/feed.xml</id><title type="html">Ingenieria de Software</title><subtitle>web with jekyll and github</subtitle><entry><title type="html">Modelos de desarrollo.</title><link href="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/15/Model-desarrollo.html" rel="alternate" type="text/html" title="Modelos de desarrollo." /><published>2020-08-15T00:00:00-05:00</published><updated>2020-08-15T00:00:00-05:00</updated><id>http://localhost:4000/Proyect-Software/jekyll/update/2020/08/15/Model-desarrollo</id><content type="html" xml:base="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/15/Model-desarrollo.html">&lt;body style=&quot;background-color:#FFE5C7;font-family: Century Schoolbook&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;
	Ingeniería de software es la aplicación de enfoques sistemáticos y disciplinados al desarrollo de software, para esto se han creado modelos y metodologías para la correcta utilización del tiempo y recursos que una empresa o entidad disponen.&lt;br&gt;
&lt;/p&gt;
&lt;a name=&quot;tema5.1&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;MODELOS TRADICIONALES&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt;
	Es el enfoque metodológico que ordena rigurosamente las etapas del proceso para el desarrollo de software, de tal forma que el inicio de cada etapa debe esperar a la finalización de la etapa anterior.&lt;br&gt;
	Formados por un conjunto de fases o actividades en las que no tienen en cuenta la naturaleza evolutiva del software.&lt;br&gt;
	Las metodologías tradicionales no se adaptan adecuadamente a los cambios, por lo que no son métodos adecuados cuando se trabaja en un entorno, donde los requisitos no pueden predecirse o bien pueden variar.
&lt;/p&gt;
Algunos de los modelos tradicionales son:&lt;br&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;h3&gt;&lt;b&gt;Modelo Secuencial(Clásico).&lt;br&gt;&lt;/b&gt;&lt;/h3&gt;
		&lt;center&gt;
			&lt;br&gt;&lt;img src=&quot;/Proyect-Software/img/tema5/figura1.png&quot; height=&quot;150px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 1.1: Diseño del modelo Secuencial.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;p align=&quot;justify&quot;&gt;&lt;b&gt; Análisis de requisitos.-&lt;/b&gt; Se debe comprender el dominio de la información, la función requerida, comportamiento, rendimiento e interconexión.&lt;/p&gt;&lt;/li&gt;
				&lt;li&gt;&lt;p align=&quot;justify&quot;&gt;&lt;b&gt;Diseño.-&lt;/b&gt; Proceso de muchos pasos centrado en cuatro atributos: estructura de datos, arquitectura de software, representación de la interfaz.&lt;/p&gt;&lt;/li&gt;
				&lt;li&gt;&lt;p align=&quot;justify&quot;&gt;&lt;b&gt;Generación de código.-&lt;/b&gt; El diseño es traducido a lenguaje máquina.&lt;/p&gt;&lt;/li&gt;
				&lt;li&gt;&lt;p align=&quot;justify&quot;&gt;&lt;b&gt;Pruebas.-&lt;/b&gt; Detección de errores y asegurar que una entrada definida produce resultados esperados.&lt;/p&gt;&lt;/li&gt;
				&lt;li&gt;&lt;p align=&quot;justify&quot;&gt;&lt;b&gt;Mantenimiento.-&lt;/b&gt; Cambios en el software que implican aplicar todos los pasos precedentes en orden.&lt;/p&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;h3&gt;&lt;b&gt;Modelo Cascada.&lt;/b&gt;&lt;/h3&gt;
		&lt;center&gt;
			&lt;br&gt;&lt;img src=&quot;/Proyect-Software/img/tema5/figura2.png&quot; height=&quot;250px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 1.2: Diseño del modelo Cascada.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;
			El modelo cascada es de plan-impulsado significa que son procesos en los que todas las actividades del proceso se planifican con antelación y el progreso se mide en contra de este plan, tiene fases separadas y distintas de especificación y desarrollo.&lt;br&gt;El modelo en cascada refleja la necesidad impuesta por la realidad de retornar con frecuencia desde una fase hacia las anteriores con la información generada al avanzar el desarrollo.
			&lt;ul&gt;
				&lt;li&gt;Análisis de requisitos.&lt;/li&gt;
				&lt;li&gt;Diseño.&lt;/li&gt;
				&lt;li&gt;Codificación.&lt;/li&gt;
				&lt;li&gt;Pruebas.&lt;/li&gt;
				&lt;li&gt;Integración&lt;/li&gt;
				&lt;li&gt;Operación y mantenimiento.&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;h3&gt;&lt;b&gt;Construcción de prototipos.&lt;/b&gt;&lt;/h3&gt;
		&lt;center&gt;
			&lt;br&gt;&lt;img src=&quot;/Proyect-Software/img/tema5/figura3.png&quot; height=&quot;250px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 1.3: Diseño del modelo de construcción de prototipos.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;
			&lt;b&gt;Paradigma:&lt;/b&gt;&lt;br&gt;Inicia con la recolección de requisitos&lt;br&gt;Se hace un diseño rápido de aspectos visibles para el cliente/usuario para generar un prototipo.&lt;br&gt;El prototipo lo evalúa el cliente/usuario para refinar los requisitos.&lt;br&gt;
			&lt;b&gt;Pudiera presentar problemas debido a:&lt;/b&gt;&lt;br&gt;
			El cliente solo ve el sistema por “fuera” y no la calidad por “dentro”; el mantenimiento no es prioridad cuando se desarrolla rápido.&lt;br&gt;
			El desarrollador, con frecuencia, hace uso de las herramientas más a la mano no de las más apropiadas
		&lt;/p&gt;
	&lt;/li&gt;
	
&lt;/ul&gt;
&lt;a name=&quot;tema5.2&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;MODELOS AGILES&lt;/b&gt;&lt;/h1&gt;
Enfatizan el desarrollo rápido, ponen el énfasis en la programación.
&lt;ul&gt;
	&lt;li&gt;
		&lt;h3&gt;&lt;b&gt;Modelo Scrum.&lt;br&gt;&lt;/b&gt;&lt;/h3&gt;
		&lt;center&gt;
			&lt;br&gt;&lt;img src=&quot;/Proyect-Software/img/tema5/figura4.png&quot; height=&quot;250px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 2.1: Equipo de desarrollo de Scrum.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;
			Scrum se basa en la teoría de control de procesos empírica o empirismo. El empirismo asegura que el conocimiento procede de la experiencia y de tomar decisiones basándose en lo que se conoce. Esta metodología emplea un enfoque iterativo e incremental para optimizar la predictibilidad y el control del riesgo, realiza entregas del proyecto en sí.&lt;br&gt;
			El equipo de desarrollo de Scrum tal como se lo muestra en la &lt;i&gt;figura 1:&lt;/i&gt;&lt;br&gt;
			&lt;ul&gt;
			&lt;li&gt;&lt;p align=&quot;justify&quot;&gt; &lt;b&gt;Scrum Master: &lt;/b&gt;Es un líder que está bajo el servicio del equipo scrum, este miembro ayuda al equipo y a los clientes externos a comprender las interacciones que pueden ser de ayuda y cuáles no lo son, además él es el encargado de asegurar que el equipo adopte las teorías, prácticas y reglas de la metodología scrum.
			&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;&lt;p align=&quot;justify&quot;&gt;&lt;b&gt;Product Owner: &lt;/b&gt;Es la persona responsable de transmitir al equipo de desarrollo la visión del producto que se desea crear, aportando la perspectiva de negocio.&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;&lt;p align=&quot;justify&quot;&gt;&lt;b&gt; Cliente: &lt;/b&gt;Son los destinatarios finales de la aplicación a desarrollar, el público objetivo del mismo. No forman parte del proceso de creación directamente, aunque podrían estar en la fase de revisión de entregables si se considera necesario.&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;&lt;p align=&quot;justify&quot;&gt;&lt;b&gt;Equipo Scrum: &lt;/b&gt;Equipo responsable de desarrollar y entregar el producto. Mantiene una organización horizontal en la que cada miembro del equipo se auto-gestiona y organiza libremente en la definición y ejecución de los distintos sprints&lt;/p&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;h3&gt;&lt;b&gt;Programacion Extrema (XP).&lt;br&gt;&lt;/b&gt;&lt;/h3&gt;
		&lt;center&gt;
			&lt;br&gt;&lt;img src=&quot;/Proyect-Software/img/tema5/figura5.png&quot; height=&quot;250px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 2.2: Diseño del modelo XP.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;
			La programación extrema es una metodología que se basa en una serie de reglas y principios que se han utilizado a lo largo de toda la historia del desarrollo de software, aplicando conjuntamente cada una de ellas de manera que creen un proceso ágil.&lt;br&gt;
			Además la programación extrema se basa en la simplicidad, la comunicación y el reciclado continúo de código
		&lt;/p&gt;
		&lt;b&gt;Pretende:&lt;/b&gt;
		&lt;ul&gt;
			&lt;li&gt;La satisfacción del cliente.&lt;/li&gt;
			&lt;li&gt;Potenciar al máximo el trabajo en grupo.&lt;/li&gt;&lt;li&gt;educir el costo del cambio en las etapas de vida del sistema.&lt;/li&gt;
			&lt;li&gt;Combinar las que han demostrado ser las mejores practicas de desarrollo de software y llevarlas al extremo.&lt;/li&gt;
		&lt;/ul&gt;
		&lt;b&gt;Establece cuatro variables:&lt;/b&gt;
		&lt;ul&gt;
			&lt;li&gt;Coste.&lt;/li&gt;
			&lt;li&gt;Tiempo.&lt;/li&gt;
			&lt;li&gt;Calidad.&lt;/li&gt;
			&lt;li&gt;Ámbito.&lt;/li&gt;
		&lt;/ul&gt;
		&lt;b&gt;Plantea cuatro valores:&lt;/b&gt;
		&lt;ul&gt;
			&lt;li&gt;Comunicación.&lt;/li&gt;
			&lt;li&gt;Sencillez.&lt;/li&gt;
			&lt;li&gt;Retroalimentación.&lt;/li&gt;
			&lt;li&gt;Valentía.&lt;/li&gt;
		&lt;/ul&gt;
		&lt;b&gt;Define cuatro actividades básicas:&lt;/b&gt;
		&lt;ul&gt;
			&lt;li&gt;Codificar.&lt;/li&gt;
			&lt;li&gt;Hacer pruebas.&lt;/li&gt;
			&lt;li&gt;Escuchar.&lt;/li&gt;
			&lt;li&gt;Diseñar.&lt;/li&gt;
		&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;h3&gt;&lt;b&gt;Crystal Clear.&lt;br&gt;&lt;/b&gt;&lt;/h3&gt;
		&lt;center&gt;
			&lt;br&gt;&lt;img src=&quot;/Proyect-Software/img/tema5/figura6.png&quot; height=&quot;250px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 2.3: Diseño del modelo Crystal Clear.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;
			Crystal es una metodología en la cual se establecen códigos de color como parte de la definición de la complejidad de la misma, si es más oscuro entonces el método es más pesado, cuánto más crítico es el sistema más rigor se necesita.&lt;br&gt;Además Crystal Clear sugiere que se defina un color para cada proyecto en función de su criticidad y tamaño.&lt;br&gt;
			Cada letra de la &lt;i&gt;figura 2.3&lt;/i&gt; representa a los riesgos potenciales:&lt;br&gt;
			&lt;b&gt;C:&lt;/b&gt; pérdida de confort debido a un fallo del sistema&lt;br&gt;
			&lt;b&gt;D:&lt;/b&gt; pérdida de dinero discrecional (nuestro dinero)&lt;br&gt;
			&lt;b&gt;E:&lt;/b&gt; pérdida de dinero esencial (este es el dinero del cual no se puede disponer)&lt;br&gt;
			&lt;b&gt;L:&lt;/b&gt; pérdida de vidas por el fallo del sistema&lt;br&gt;
			Además el color indica el numero de personas que se requiere:&lt;br&gt;
			&lt;b&gt;Clear:&lt;/b&gt; es para equipos de 8 personas o menos.&lt;br&gt;
			&lt;b&gt;Amarillo:&lt;/b&gt; para equipos de 10-20 personas.&lt;br&gt;
			&lt;b&gt;Naranja:&lt;/b&gt; para equipos de 20-50 personas.&lt;br&gt;
			&lt;b&gt;Rojo:&lt;/b&gt; para equipos de 50-100 y así sucesivamente pasando por el marrón y violeta.&lt;br&gt;
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">Ingeniería de software es la aplicación de enfoques sistemáticos y disciplinados al desarrollo de software, para esto se han creado modelos y metodologías para la correcta utilización del tiempo y recursos que una empresa o entidad disponen. MODELOS TRADICIONALES Es el enfoque metodológico que ordena rigurosamente las etapas del proceso para el desarrollo de software, de tal forma que el inicio de cada etapa debe esperar a la finalización de la etapa anterior. Formados por un conjunto de fases o actividades en las que no tienen en cuenta la naturaleza evolutiva del software. Las metodologías tradicionales no se adaptan adecuadamente a los cambios, por lo que no son métodos adecuados cuando se trabaja en un entorno, donde los requisitos no pueden predecirse o bien pueden variar. Algunos de los modelos tradicionales son: Modelo Secuencial(Clásico). figura 1.1: Diseño del modelo Secuencial. Análisis de requisitos.- Se debe comprender el dominio de la información, la función requerida, comportamiento, rendimiento e interconexión. Diseño.- Proceso de muchos pasos centrado en cuatro atributos: estructura de datos, arquitectura de software, representación de la interfaz. Generación de código.- El diseño es traducido a lenguaje máquina. Pruebas.- Detección de errores y asegurar que una entrada definida produce resultados esperados. Mantenimiento.- Cambios en el software que implican aplicar todos los pasos precedentes en orden. Modelo Cascada. figura 1.2: Diseño del modelo Cascada. El modelo cascada es de plan-impulsado significa que son procesos en los que todas las actividades del proceso se planifican con antelación y el progreso se mide en contra de este plan, tiene fases separadas y distintas de especificación y desarrollo.El modelo en cascada refleja la necesidad impuesta por la realidad de retornar con frecuencia desde una fase hacia las anteriores con la información generada al avanzar el desarrollo. Análisis de requisitos. Diseño. Codificación. Pruebas. Integración Operación y mantenimiento. Construcción de prototipos. figura 1.3: Diseño del modelo de construcción de prototipos. Paradigma:Inicia con la recolección de requisitosSe hace un diseño rápido de aspectos visibles para el cliente/usuario para generar un prototipo.El prototipo lo evalúa el cliente/usuario para refinar los requisitos. Pudiera presentar problemas debido a: El cliente solo ve el sistema por “fuera” y no la calidad por “dentro”; el mantenimiento no es prioridad cuando se desarrolla rápido. El desarrollador, con frecuencia, hace uso de las herramientas más a la mano no de las más apropiadas MODELOS AGILES Enfatizan el desarrollo rápido, ponen el énfasis en la programación. Modelo Scrum. figura 2.1: Equipo de desarrollo de Scrum. Scrum se basa en la teoría de control de procesos empírica o empirismo. El empirismo asegura que el conocimiento procede de la experiencia y de tomar decisiones basándose en lo que se conoce. Esta metodología emplea un enfoque iterativo e incremental para optimizar la predictibilidad y el control del riesgo, realiza entregas del proyecto en sí. El equipo de desarrollo de Scrum tal como se lo muestra en la figura 1: Scrum Master: Es un líder que está bajo el servicio del equipo scrum, este miembro ayuda al equipo y a los clientes externos a comprender las interacciones que pueden ser de ayuda y cuáles no lo son, además él es el encargado de asegurar que el equipo adopte las teorías, prácticas y reglas de la metodología scrum. Product Owner: Es la persona responsable de transmitir al equipo de desarrollo la visión del producto que se desea crear, aportando la perspectiva de negocio. Cliente: Son los destinatarios finales de la aplicación a desarrollar, el público objetivo del mismo. No forman parte del proceso de creación directamente, aunque podrían estar en la fase de revisión de entregables si se considera necesario. Equipo Scrum: Equipo responsable de desarrollar y entregar el producto. Mantiene una organización horizontal en la que cada miembro del equipo se auto-gestiona y organiza libremente en la definición y ejecución de los distintos sprints Programacion Extrema (XP). figura 2.2: Diseño del modelo XP. La programación extrema es una metodología que se basa en una serie de reglas y principios que se han utilizado a lo largo de toda la historia del desarrollo de software, aplicando conjuntamente cada una de ellas de manera que creen un proceso ágil. Además la programación extrema se basa en la simplicidad, la comunicación y el reciclado continúo de código Pretende: La satisfacción del cliente. Potenciar al máximo el trabajo en grupo.educir el costo del cambio en las etapas de vida del sistema. Combinar las que han demostrado ser las mejores practicas de desarrollo de software y llevarlas al extremo. Establece cuatro variables: Coste. Tiempo. Calidad. Ámbito. Plantea cuatro valores: Comunicación. Sencillez. Retroalimentación. Valentía. Define cuatro actividades básicas: Codificar. Hacer pruebas. Escuchar. Diseñar. Crystal Clear. figura 2.3: Diseño del modelo Crystal Clear. Crystal es una metodología en la cual se establecen códigos de color como parte de la definición de la complejidad de la misma, si es más oscuro entonces el método es más pesado, cuánto más crítico es el sistema más rigor se necesita.Además Crystal Clear sugiere que se defina un color para cada proyecto en función de su criticidad y tamaño. Cada letra de la figura 2.3 representa a los riesgos potenciales: C: pérdida de confort debido a un fallo del sistema D: pérdida de dinero discrecional (nuestro dinero) E: pérdida de dinero esencial (este es el dinero del cual no se puede disponer) L: pérdida de vidas por el fallo del sistema Además el color indica el numero de personas que se requiere: Clear: es para equipos de 8 personas o menos. Amarillo: para equipos de 10-20 personas. Naranja: para equipos de 20-50 personas. Rojo: para equipos de 50-100 y así sucesivamente pasando por el marrón y violeta.</summary></entry><entry><title type="html">El ciclo de vida del Software.</title><link href="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/15/Ciclo-vida-soft.html" rel="alternate" type="text/html" title="El ciclo de vida del Software." /><published>2020-08-15T00:00:00-05:00</published><updated>2020-08-15T00:00:00-05:00</updated><id>http://localhost:4000/Proyect-Software/jekyll/update/2020/08/15/Ciclo-vida-soft</id><content type="html" xml:base="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/15/Ciclo-vida-soft.html">&lt;body style=&quot;background-color:#FFE5C7;font-family: Century Schoolbook&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;Conocer el ciclo de vida del software es vital para el desarrollo del mismo ya que cuando no se sigue un ciclo devida hay una alta probabilidad de error en el software además de no satisfacer los requisitos del usuario, es por eso que se crearon normas y estándares con el fin de gestionar, proporcionar un marco para el desarrollo, dando adquisición, suministro, y mantenimiento del software.&lt;/p&gt;
&lt;a name=&quot;tema4.1&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;DEFINICION Y ETAPAS.&lt;/b&gt;&lt;/h1&gt;

&lt;p align=&quot;justify&quot;&gt;El ciclo de vida del software, detalla todo el marco del ciclo del software cubriendo desde la conceptualización de las ideas iniciales hasta la finalización de su uso, donde se describen las acciones que se debe llevar a cabo cuando se desarrolla el software, llevando un orden secuencial y coherente entre cada etapa.&lt;br&gt;Es el proceso que se sigue para construir, entregar y hacer evolucionar el software, desde la concepción de una idea hasta la entrega y retiro del sistema.&lt;br&gt;
Un proceso de desarrollo de software tiene como propósito la producción eficaz y eficiente de un producto software que reúna los requisitos del cliente. Debido a esta diversidad, es difícil automatizar todo un proceso de desarrollo de software. A pesar de la variedad de propuestas de proceso de software, existe un conjunto de actividades fundamentales que se encuentran presentes en todos ellos.&lt;br&gt;
&lt;center&gt;
	&lt;img src=&quot;/Proyect-Software/img/tema4/figura1.png&quot; height=&quot;250px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
	&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 1: Ilustración de las etapas del ciclo de vida del software.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;h4 align=&quot;left &quot;&gt;&lt;b&gt;Procesos primarios del ciclo de vida del software&lt;br&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;Adquisición.&lt;/li&gt;
	&lt;li&gt;Suministro.&lt;/li&gt;
	&lt;li&gt;Desarrollo.&lt;/li&gt;
	&lt;li&gt;Operación.&lt;/li&gt;
	&lt;li&gt;Mantenimiento.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 align=&quot;left &quot;&gt;&lt;b&gt;Procesos de soporte del ciclo de vida del software&lt;br&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;Documentación.&lt;/li&gt;
	&lt;li&gt;Gestión de la configuración.&lt;/li&gt;
	&lt;li&gt;Aseguramiento de la calidad.&lt;/li&gt;
	&lt;li&gt;verificación.&lt;/li&gt;
	&lt;li&gt;Validación.&lt;/li&gt;
	&lt;li&gt;Reuniones de revisión.&lt;/li&gt;
	&lt;li&gt;Aditorías.&lt;/li&gt;
	&lt;li&gt;Resolución de problemas.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 align=&quot;left &quot;&gt;&lt;b&gt;Procesos organizacionales&lt;br&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;Gestión.&lt;/li&gt;
	&lt;li&gt;Infraestructura.&lt;/li&gt;
	&lt;li&gt;Mejora.&lt;/li&gt;
	&lt;li&gt;Formación.&lt;/li&gt;
&lt;/ul&gt;

&lt;a name=&quot;tema4.2&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;ÁMBITO GENERAL DE: REQUERIMIENTOS, ANÁLISIS, DISEÑO Y PRUEBAS DE SOFTWARE.&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt;
	&lt;ol&gt;
		&lt;li&gt;&lt;b&gt;Análisis de requerimientos.- &lt;/b&gt; &lt;p align=&quot;justify&quot;&gt; Se extraen los requisitos del producto de software. En esta etapa la habilidad y experiencia en la ingeniería del software es crítica para reconocer requisitos incompletos, ambiguos o contradictorios. Usualmente el cliente/usuario tiene una visión incompleta/inexacta de lo que necesita y es necesario ayudarle para obtener la visión completa de los requerimientos.  El contenido de comunicación en esta etapa es muy intenso ya que el objetivo es eliminar la ambigüedad en la medida de lo posible.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Diseño y arquitectura.-&lt;/b&gt;&lt;p align=&quot;justify&quot;&gt;
	Determinar como funcionará de forma general sin entrar en detalles incorporando consideraciones de la implementación tecnológica, como el hardware, la red, etc.  Consiste en el diseño de los componentes del sistema que dan respuesta a las funcionalidades descritas en la segunda etapa también conocidas como las entidades de negocio. Generalmente se realiza en base a diagramas que permitan describir las interacciones entre las entidades y su secuenciado.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Prueba.-&lt;/b&gt; &lt;p align=&quot;justify&quot;&gt; Consiste en comprobar que el software responda/realice correctamente las tareas indicadas en la especificación. Es una buena praxis realizar pruebas a distintos niveles (por ejemplo primero a nivel unitario y después de forma integrada de cada componente) y por equipos diferenciados del de desarrollo (pruebas cruzadas entre los programadores o realizadas por un área de test independiente).&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Mantenimiento.-&lt;/b&gt;&lt;p align=&quot;justify&quot;&gt;En esta etapa se realizan un mantenimiento correctivo (resolver errores) y un mantenimiento evolutivo (mejorar la funcionalidades y/o dar respuesta a nuevos requisitos)&lt;/p&gt;.&lt;/li&gt;
	&lt;/ol&gt;
&lt;/p&gt;

&lt;/body&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">Conocer el ciclo de vida del software es vital para el desarrollo del mismo ya que cuando no se sigue un ciclo devida hay una alta probabilidad de error en el software además de no satisfacer los requisitos del usuario, es por eso que se crearon normas y estándares con el fin de gestionar, proporcionar un marco para el desarrollo, dando adquisición, suministro, y mantenimiento del software. DEFINICION Y ETAPAS.</summary></entry><entry><title type="html">Fundamentos a la Ingeniería de Software</title><link href="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/14/Fundamentos-ing-Software.html" rel="alternate" type="text/html" title="Fundamentos a la Ingeniería de Software" /><published>2020-08-14T00:00:00-05:00</published><updated>2020-08-14T00:00:00-05:00</updated><id>http://localhost:4000/Proyect-Software/jekyll/update/2020/08/14/Fundamentos-ing-Software</id><content type="html" xml:base="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/14/Fundamentos-ing-Software.html">&lt;body style=&quot;background-color:#FFE5C7;font-family: Century Schoolbook&quot;&gt;
&lt;h4&gt;&lt;b&gt;¿Cuál es la diferencia entre ingeniería de software y ciencias de la computación?&lt;br&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;p align=&quot;justify&quot;&gt;Las ciencias de la computación estan enfocadas en la teoría y
fundamentos, en cambio la ingeniería de software se enfoca en el sentido práctico del desarrollo y en la distribución de software.&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;¿Cuál es la diferencia entre ingeniería de software e ingeniería de sistemas?&lt;br&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;p align=&quot;justify&quot;&gt;La ingeniería de sistemas se interesa por todos los aspectos del desarrollo de sistemas basados en computadoras, incluidos hardware, software e ingeniería de procesos. La ingeniería de software es parte de este proceso más general.&lt;/p&gt;
&lt;br&gt;
&lt;a name=&quot;tema1.1&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;DEFINICIONES Y OBJETIVOS DE LA INGENIERIA DE SOFTWARE&lt;/b&gt;&lt;/h1&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;¿Que es Software?&lt;br&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt;Es un producto que diseñan y construyen los ingenieros de software. Esto abarca programas que se ejecutan dentro de una computadora de cualquier tamaño y arquitectura, documentos que comprenden formularios virtuales e impresos y datos que combinan números y texto y también incluyen representaciones de la información de audio, vídeo e imágenes.&lt;/p&gt;
&lt;h1 align=&quot;left &quot;&gt;&lt;b&gt;Objetivo&lt;br&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt; Planificar el desarrollo del software como un proceso metodológico de construcción y de gestión de proyectos soportado en estándares utilizados en la industria de la ingeniería de software para diseñar software de calidad.&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Atributos de un buen software.&lt;br&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;center&gt;
	&lt;img src=&quot;/Proyect-Software/img/tema1/figura2.png&quot;&gt;&lt;br&gt;
	&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 1: Referencia de un buen Software con sus atributos.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
&lt;/center&gt;
&lt;p align=&quot;justify&quot;&gt;El buen software debe entregar al usuario la funcionalidad y el desempeño requeridos, y debe ser sustentable, confiable y utilizable.&lt;br&gt;Los atributos esenciales de un buen software son:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;b style=&quot;color: red&quot;&gt;Mantenimiento.- &lt;/b&gt; &lt;p align=&quot;justify&quot;&gt;El software debe escribirse de tal forma que pueda evolucionar para satisfacer las necesidades cambiantes de los clientes &lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: red&quot;&gt;Confiabilidad y seguridad.- &lt;/b&gt;&lt;p align=&quot;justify&quot;&gt; La confiabilidad del software incluye una variedad de características que incluyen confiabilidad, seguridad y protección, el software confiable no debe causar daños físicos o económicos en caso de falla del sistema.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: red&quot;&gt;Eficiencia.- &lt;/b&gt;&lt;p align=&quot;justify&quot;&gt;El software no debe desperdiciar los recursos del sistema, como la memoria y los ciclos del procesador. Por lo tanto, la eficiencia incluye la capacidad de respuesta, el tiempo de procesamiento, la utilización de la memoria, etc. &lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;
		&lt;b style=&quot;color: red&quot;&gt;Aceptabilidad.- &lt;/b&gt;&lt;p align=&quot;justify&quot;&gt;El software debe ser aceptable para el tipo de usuarios para el que está diseñado. Esto significa que debe ser comprensible, utilizable y compatible con otros sistemas que utilicen.&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;a name=&quot;tema1.2&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;LA EVOLUCION DEL SOFTWARE&lt;/b&gt;&lt;/h1&gt;
&lt;b&gt;Primeros años (1950 - 1960)&lt;/b&gt;&lt;br&gt;
&lt;ul&gt;
	&lt;li&gt;Lo mas importante era el hardware, el software solo era un complemento.&lt;/li&gt;
	&lt;li&gt;Se utilizaba el procesamiento por lotes.&lt;/li&gt;
	&lt;li&gt;Aún no existia ninguna documentación o metodología.&lt;/li&gt;
&lt;/ul&gt;
&lt;b&gt;Segunda Era (1960 - 1970)&lt;/b&gt;&lt;br&gt;
&lt;ul&gt;
	&lt;li&gt;El software se considera un producto que se distribuye para macro y mini computadoras.&lt;/li&gt;
	&lt;li&gt;Inicia la industria del software con la idea de desarrollar el mejor paquete y asi ganar dinero.&lt;/li&gt;
	&lt;li&gt;Se introdujo nuevos conceptos de iteracción hombre-maquina, gracias a la multiprogramacion y sistemas multiusuario.&lt;/li&gt;
	&lt;li&gt;El mantenimiento del software comenzó a ser algo mucho mas crítico.&lt;/li&gt;
&lt;/ul&gt;

&lt;b&gt;Tercera Era (1970 - 1990)&lt;/b&gt;&lt;br&gt;
&lt;ul&gt;
	&lt;li&gt;El uso personal del software aún no era común.&lt;/li&gt;
	&lt;li&gt;Incrementa notablemente la dificultad debido a sistemas distribuidos.&lt;/li&gt;
	&lt;li&gt;La presión sobre los desarrolladores era muy alta.&lt;/li&gt;
	&lt;li&gt;Incrementa el uso de acceso inmediato a los datos.&lt;/li&gt;
&lt;/ul&gt;

&lt;b&gt;Cuarta Era (1990 - 2000)&lt;/b&gt;&lt;br&gt;
&lt;ul&gt;
	&lt;li&gt;En esta epoca la industria del software es considerada la cuna de la economía del mundo.&lt;/li&gt;
	&lt;li&gt;Se denominan los sistemas cliente/servidor.&lt;/li&gt;
	&lt;li&gt;Sistemas de cómputo personales potentes.&lt;/li&gt;
	&lt;li&gt;Una gran demanda del internet y el comercio electrónico.&lt;/li&gt;
	&lt;li&gt;Gran auge de las tecnologías orientada a objetos.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;
	&lt;img src=&quot;/Proyect-Software/img/tema1/figura1.png&quot;&gt;&lt;br&gt;
	&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 2: Similitud a la evolucion del software&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
&lt;/center&gt;


&lt;a name=&quot;tema1.3&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;LA CRISIS DEL SOFTWARE&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt;
	La crisis del software se identificó por primera vez en 1968, año en el que se desarrolló la primera conferencia sobre desarrollo de software, y en la que se implementaron los términos “crisis del software” para definir a los problemas que surgían en el desarrollo de sistemas de software, e ingeniería del software para describir el conjunto de conocimientos que existían en aquel estado inicial.&lt;br&gt;
	Muchas de las causas de la crisis del software se pueden encontrar en una mitología que surge durante los primeros años del desarrollo del software.&lt;br&gt;Algunos ejemplos de mitos que causan la crisis del software:
	&lt;ul&gt;
		&lt;li&gt;&lt;b&gt;De gestión.- &lt;/b&gt; &quot;Tenemos ya un libro que está lleno de estándares y procedimientos para construir software.&quot;&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;Del cliente.- &lt;/b&gt; &quot;En los clientes que solicitan una aplicación de software los mitos les crean falsas expectativas y finalmente quedan insatisfechos,&quot;Una vez que escribimos el programa y hacemos que funcione, nuestro trabajo ha terminado&quot;&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;Del cliente.- &lt;/b&gt; &quot;En los clientes que solicitan una aplicación de software los mitos les crean falsas expectativas y finalmente quedan insatisfechos,&quot;Una vez que escribimos el programa y hacemos que funcione, nuestro trabajo ha terminado&quot;&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;De los ingenieros de software.- &lt;/b&gt; &quot;Para  administrar  en  forma adecuada  el  proyecto, se  debe  tener un plan detallado de todo el proyecto desde el principio&quot;&lt;/li&gt;
	&lt;/ul&gt;

&lt;/p&gt;


&lt;/body&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">¿Cuál es la diferencia entre ingeniería de software y ciencias de la computación? Las ciencias de la computación estan enfocadas en la teoría y fundamentos, en cambio la ingeniería de software se enfoca en el sentido práctico del desarrollo y en la distribución de software. ¿Cuál es la diferencia entre ingeniería de software e ingeniería de sistemas? La ingeniería de sistemas se interesa por todos los aspectos del desarrollo de sistemas basados en computadoras, incluidos hardware, software e ingeniería de procesos. La ingeniería de software es parte de este proceso más general. DEFINICIONES Y OBJETIVOS DE LA INGENIERIA DE SOFTWARE ¿Que es Software? Es un producto que diseñan y construyen los ingenieros de software. Esto abarca programas que se ejecutan dentro de una computadora de cualquier tamaño y arquitectura, documentos que comprenden formularios virtuales e impresos y datos que combinan números y texto y también incluyen representaciones de la información de audio, vídeo e imágenes. Objetivo Planificar el desarrollo del software como un proceso metodológico de construcción y de gestión de proyectos soportado en estándares utilizados en la industria de la ingeniería de software para diseñar software de calidad. Atributos de un buen software. figura 1: Referencia de un buen Software con sus atributos. El buen software debe entregar al usuario la funcionalidad y el desempeño requeridos, y debe ser sustentable, confiable y utilizable.Los atributos esenciales de un buen software son: Mantenimiento.- El software debe escribirse de tal forma que pueda evolucionar para satisfacer las necesidades cambiantes de los clientes Confiabilidad y seguridad.- La confiabilidad del software incluye una variedad de características que incluyen confiabilidad, seguridad y protección, el software confiable no debe causar daños físicos o económicos en caso de falla del sistema. Eficiencia.- El software no debe desperdiciar los recursos del sistema, como la memoria y los ciclos del procesador. Por lo tanto, la eficiencia incluye la capacidad de respuesta, el tiempo de procesamiento, la utilización de la memoria, etc. Aceptabilidad.- El software debe ser aceptable para el tipo de usuarios para el que está diseñado. Esto significa que debe ser comprensible, utilizable y compatible con otros sistemas que utilicen. LA EVOLUCION DEL SOFTWARE Primeros años (1950 - 1960) Lo mas importante era el hardware, el software solo era un complemento. Se utilizaba el procesamiento por lotes. Aún no existia ninguna documentación o metodología. Segunda Era (1960 - 1970) El software se considera un producto que se distribuye para macro y mini computadoras. Inicia la industria del software con la idea de desarrollar el mejor paquete y asi ganar dinero. Se introdujo nuevos conceptos de iteracción hombre-maquina, gracias a la multiprogramacion y sistemas multiusuario. El mantenimiento del software comenzó a ser algo mucho mas crítico.</summary></entry><entry><title type="html">Proceso del Software.</title><link href="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/14/Proceso-soft.html" rel="alternate" type="text/html" title="Proceso del Software." /><published>2020-08-14T00:00:00-05:00</published><updated>2020-08-14T00:00:00-05:00</updated><id>http://localhost:4000/Proyect-Software/jekyll/update/2020/08/14/Proceso-soft</id><content type="html" xml:base="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/14/Proceso-soft.html">&lt;body style=&quot;background-color:#FFE5C7;font-family: Century Schoolbook&quot;&gt;
	&lt;p align=&quot;justify&quot;&gt; El proceso de software es un conjunto estructurado de actividades, cuya meta es el desarrollo o evolución de un software eficaz y eficiente que reuna los requisitos del cliente.
	Un conjunto estructurado de actividades necesarias para desarrollar un sistema de software.&lt;/p&gt;
&lt;a name=&quot;tema3.1&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;DEFINICION DE PROCESO DEL SOFTWARE.&lt;br&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt;
	El proceso de desarrollo de software varia segun el proyecto.&lt;br&gt;No existe un proceso de software general y que este sea operativo para todos los contextos de proyectos de desarrollo, debido a esta variedad, es difícil automatizar todo un proceso de desarrollo de software.&lt;br&gt;
	Exite algunos procesos de software diferentes, pero todos implican lo siguiente: 
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;b&gt;Especificación&lt;/b&gt;&lt;p align=&quot;justify&quot;&gt;La definición de lo que el sistema debe hacer.&lt;/p&gt;
	&lt;/li&gt; 
	&lt;li&gt;&lt;b&gt;Diseño e implementación&lt;/b&gt;&lt;p align=&quot;justify&quot;&gt;La definición de la organización del sistema y la implementación del sistema.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Validación&lt;/b&gt;&lt;p align=&quot;justify&quot;&gt;La comprobación de que hace lo que quiere el cliente.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Evolución&lt;/b&gt;&lt;p align=&quot;justify&quot;&gt;El cambio del sistema en respuesta a las necesidades cambiantes de los clientes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;justify&quot;&gt;
	Otra perspectiva utilizada para determinar los elementos del proceso de desarrollo de software es establecer las relaciones entre elementos que permitan responder &lt;b&gt;quién&lt;/b&gt; debe hacer &lt;b&gt;qué&lt;/b&gt;, &lt;b&gt;cuándo&lt;/b&gt; y &lt;b&gt;cómo&lt;/b&gt; debe hacerlo.&lt;br&gt;
&lt;/p&gt;
&lt;center&gt;
	&lt;img src=&quot;/Proyect-Software/img/tema3/figura1-1.png&quot;&gt;&lt;br&gt;
	&lt;h5&gt;&lt;i&gt;&lt;u&gt;Figura 1: relación entre elementos del proceso del software&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
&lt;/center&gt;
&lt;p align=&quot;justify&quot;&gt;
	Como podemos observar en la &lt;i&gt;figura 1&lt;/i&gt; donde señala los elementos que se relacionan en el proceso del software, donde:&lt;br&gt;
	&lt;b&gt;-Quién:&lt;/b&gt; Serían las personas que participan en el desarrollo del software desempeñando roles especificos.&lt;br&gt;
	&lt;b&gt;-Qué:&lt;/b&gt; Sería Un objeto o artefacto(como indica la &lt;i&gt;figura 1&lt;/i&gt;) que es producido por un rol en una de sus actividades.&lt;br&gt;
	&lt;b&gt;-Cómo y Cuándo:&lt;/b&gt; Sería las actividades que siguen una serie de pasos que llevan a cabo un rol durante el proceso de desarrollo. 
&lt;/p&gt;
&lt;br&gt;
&lt;a name=&quot;tema3.2&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;ESTANDARES RELACIONADOS CON EL PROCESO DE SOFTWARE&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;/p&gt;
Desde la identificación del fenómeno “crisis del software”, han sido muchas las organizaciones que han realizado con mayor o menor rigor el análisis de problemas en el desarrollo de sistemas de software.&lt;br&gt;Sus análisis se han encaminado a la localización de las causas, y a la exposición en textos didácticos, normativos o estándares de procesos o prácticas necesarias para abordar el desarrollo, mantenimiento y operación con las garantizando éxito.&lt;br&gt;
Han sido muchos los departamentos de universidades, organismos de normalización o investigación nacionales o internacionales, sociedades de profesionales, departamentos de defensa, departamentos de calidad y procesos de empresas los que han ido generando normas y estándares.&lt;br&gt;
Algunas de las normas o estandares son las siguientes.-
&lt;ol&gt;
	&lt;li&gt;&lt;b&gt;ISO/IEC 12207&lt;/b&gt;
		&lt;center&gt;
			&lt;img src=&quot;/Proyect-Software/img/tema3/figura1.png&quot; height=&quot;100px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 1: Logo de la Organización Internacional de Normalización.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;La norma ISO/IEC 12207 publicada en 1995 por la ISO (Organización Internacional de Normalización su logo es como se aprecia en la &lt;i&gt;figura 1&lt;/i&gt;) junto con la IEC (Comisión Internacional Electrotécnica ), fue la primera norma en facilitar un vasto conjunto de procesos del ciclo de la vida del software, no se trata de un estándar de certificación, sino de un estándar para la normalización.&lt;br&gt;
		El objetivo de la norma ISO/IEC 12207, es proporcionar un conjunto de procesos bien definidos, que permitan facilitar la comunicación entre compradores, proveedores y demás inmersos en el ciclo de vida del software&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;SWEBOK&lt;/b&gt;
		&lt;center&gt;
			&lt;img src=&quot;/Proyect-Software/img/tema3/figura2.png&quot; height=&quot;50px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 1: Logo de SWEBOK.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;Software Engineering Body of Knowledge, traducido al español “Cuerpo de conocimientos de ingeniería de software”, más conocido por su abreviación SWEBOK, es un proyecto que empezó sus actividades en 1997 dentro del comité SWECC (Software Engineering Coordinating Committee, fundada en 1993).&lt;br&gt;
		El propósito del proyecto SWEBOK es elaborar un documento con el objetivo de clasificar los temas de la ingeniería del software, también disponer acceso mediante las temáticas al conocimiento de la ingeniería del software, así poder fomentar una fuerte visión de la ingeniería del software por todo el mundo.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;CMMI&lt;/b&gt;
		&lt;center&gt;
			&lt;img src=&quot;/Proyect-Software/img/tema3/figura3.png&quot; height=&quot;100px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 1: Logo de CMMI.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;Capability Maturity Model Integration (CMMI), traducido al español Integración de sistemas modelos de madurez de capacidades, es un modelo de procesos que contiene las mejores practicas para un proyecto de software, que va desde el desarrollo del mismo, hasta la adquisición y operación del producto.&lt;br&gt;
		Este modelo fue desarrollado por la Universidad Carnegie Mellon (CMU) en el año 1987, creado con el propósito de evaluar la madurez de los procesos de una organización y proporcionar una orientación referente a cómo mejorar los procesos que darán lugar a mejores productos, esto quiere decir que el modelo CMMI sirve para la evaluación de las organizaciones con el objetivo de poder determinar posibles riesgos afecten los procesos del desarrollo.&lt;br&gt;
		Los beneficios del modelo CMMI aparte de permitir optimizar procesos de negocios, es que también permite la unión de la experiencia adquirida en diferentes zonas prácticas, además de cumplir de forma mucho mas completa con las normas ISO.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;PMBOK&lt;/b&gt;
		&lt;center&gt;
			&lt;img src=&quot;/Proyect-Software/img/tema3/figura4.png&quot; height=&quot;100px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
			&lt;h5&gt;&lt;i&gt;&lt;u&gt;figura 1: Logo de CMMI.&lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
		&lt;/center&gt;
		&lt;p align=&quot;justify&quot;&gt;La Guía de los Fundamentos para la Dirección de Proyectos, o en su abreviación PMBOK, es una norma desarrollada por el Project Management Instituto (PMI), donde detalla las pautas, conocimiento y practicas que se pueden aplicar a diversos proyectos, el propósito del PMBOK es la aplicación de conocimientos, procesos, habilidades, herramientas y técnicas, además su intención es que sea lo más entendible posible para poder guiar adecuadamente las buenas prácticas relacionadas a la gestión, la administración y la dirección de proyectos.&lt;br&gt;
		La guía PMBOK está basada en procesos, lo que significa que ésta describe el trabajo aplicado en los procesos. Este enfoque es coherente, y muy similar, al mismo usado en otros estándares de gestión. Los procesos se superponen e interactúan a lo largo de la realización de las fases del proyecto.&lt;br&gt;
		El PMBOK ha sido diseñado por varios profesionales de esta disciplina y documenta la información necesaria para iniciar, planificar, ejecutar, supervisar, controlar y cerrar un proyecto, además establecen los grupos de procesos y áreas de conocimiento que se deben implementar en cada una de las etapas de un proyecto.&lt;br&gt;
		Es importante resaltar que este documento aporta gran variedad de definiciones relacionadas en los fundamentos de la dirección de proyectos y que es necesario que todo profesional conozca, maneje e implemente todas las herramientas que el PMBOK aporta.
		&lt;/p&gt;
	&lt;/li&gt;

&lt;/ol&gt;

&lt;/body&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">El proceso de software es un conjunto estructurado de actividades, cuya meta es el desarrollo o evolución de un software eficaz y eficiente que reuna los requisitos del cliente. Un conjunto estructurado de actividades necesarias para desarrollar un sistema de software. DEFINICION DE PROCESO DEL SOFTWARE. El proceso de desarrollo de software varia segun el proyecto.No existe un proceso de software general y que este sea operativo para todos los contextos de proyectos de desarrollo, debido a esta variedad, es difícil automatizar todo un proceso de desarrollo de software. Exite algunos procesos de software diferentes, pero todos implican lo siguiente: EspecificaciónLa definición de lo que el sistema debe hacer. Diseño e implementaciónLa definición de la organización del sistema y la implementación del sistema. ValidaciónLa comprobación de que hace lo que quiere el cliente. EvoluciónEl cambio del sistema en respuesta a las necesidades cambiantes de los clientes. Otra perspectiva utilizada para determinar los elementos del proceso de desarrollo de software es establecer las relaciones entre elementos que permitan responder quién debe hacer qué, cuándo y cómo debe hacerlo. Figura 1: relación entre elementos del proceso del software Como podemos observar en la figura 1 donde señala los elementos que se relacionan en el proceso del software, donde: -Quién: Serían las personas que participan en el desarrollo del software desempeñando roles especificos. -Qué: Sería Un objeto o artefacto(como indica la figura 1) que es producido por un rol en una de sus actividades. -Cómo y Cuándo: Sería las actividades que siguen una serie de pasos que llevan a cabo un rol durante el proceso de desarrollo. ESTANDARES RELACIONADOS CON EL PROCESO DE SOFTWARE Desde la identificación del fenómeno “crisis del software”, han sido muchas las organizaciones que han realizado con mayor o menor rigor el análisis de problemas en el desarrollo de sistemas de software.Sus análisis se han encaminado a la localización de las causas, y a la exposición en textos didácticos, normativos o estándares de procesos o prácticas necesarias para abordar el desarrollo, mantenimiento y operación con las garantizando éxito. Han sido muchos los departamentos de universidades, organismos de normalización o investigación nacionales o internacionales, sociedades de profesionales, departamentos de defensa, departamentos de calidad y procesos de empresas los que han ido generando normas y estándares. Algunas de las normas o estandares son las siguientes.- ISO/IEC 12207 figura 1: Logo de la Organización Internacional de Normalización. La norma ISO/IEC 12207 publicada en 1995 por la ISO (Organización Internacional de Normalización su logo es como se aprecia en la figura 1) junto con la IEC (Comisión Internacional Electrotécnica ), fue la primera norma en facilitar un vasto conjunto de procesos del ciclo de la vida del software, no se trata de un estándar de certificación, sino de un estándar para la normalización. El objetivo de la norma ISO/IEC 12207, es proporcionar un conjunto de procesos bien definidos, que permitan facilitar la comunicación entre compradores, proveedores y demás inmersos en el ciclo de vida del software SWEBOK figura 1: Logo de SWEBOK. Software Engineering Body of Knowledge, traducido al español “Cuerpo de conocimientos de ingeniería de software”, más conocido por su abreviación SWEBOK, es un proyecto que empezó sus actividades en 1997 dentro del comité SWECC (Software Engineering Coordinating Committee, fundada en 1993). El propósito del proyecto SWEBOK es elaborar un documento con el objetivo de clasificar los temas de la ingeniería del software, también disponer acceso mediante las temáticas al conocimiento de la ingeniería del software, así poder fomentar una fuerte visión de la ingeniería del software por todo el mundo. CMMI figura 1: Logo de CMMI. Capability Maturity Model Integration (CMMI), traducido al español Integración de sistemas modelos de madurez de capacidades, es un modelo de procesos que contiene las mejores practicas para un proyecto de software, que va desde el desarrollo del mismo, hasta la adquisición y operación del producto. Este modelo fue desarrollado por la Universidad Carnegie Mellon (CMU) en el año 1987, creado con el propósito de evaluar la madurez de los procesos de una organización y proporcionar una orientación referente a cómo mejorar los procesos que darán lugar a mejores productos, esto quiere decir que el modelo CMMI sirve para la evaluación de las organizaciones con el objetivo de poder determinar posibles riesgos afecten los procesos del desarrollo. Los beneficios del modelo CMMI aparte de permitir optimizar procesos de negocios, es que también permite la unión de la experiencia adquirida en diferentes zonas prácticas, además de cumplir de forma mucho mas completa con las normas ISO. PMBOK figura 1: Logo de CMMI. La Guía de los Fundamentos para la Dirección de Proyectos, o en su abreviación PMBOK, es una norma desarrollada por el Project Management Instituto (PMI), donde detalla las pautas, conocimiento y practicas que se pueden aplicar a diversos proyectos, el propósito del PMBOK es la aplicación de conocimientos, procesos, habilidades, herramientas y técnicas, además su intención es que sea lo más entendible posible para poder guiar adecuadamente las buenas prácticas relacionadas a la gestión, la administración y la dirección de proyectos. La guía PMBOK está basada en procesos, lo que significa que ésta describe el trabajo aplicado en los procesos. Este enfoque es coherente, y muy similar, al mismo usado en otros estándares de gestión. Los procesos se superponen e interactúan a lo largo de la realización de las fases del proyecto. El PMBOK ha sido diseñado por varios profesionales de esta disciplina y documenta la información necesaria para iniciar, planificar, ejecutar, supervisar, controlar y cerrar un proyecto, además establecen los grupos de procesos y áreas de conocimiento que se deben implementar en cada una de las etapas de un proyecto. Es importante resaltar que este documento aporta gran variedad de definiciones relacionadas en los fundamentos de la dirección de proyectos y que es necesario que todo profesional conozca, maneje e implemente todas las herramientas que el PMBOK aporta.</summary></entry><entry><title type="html">Proceso de Ingeniería de software.</title><link href="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/14/Proceso-ing.html" rel="alternate" type="text/html" title="Proceso de Ingeniería de software." /><published>2020-08-14T00:00:00-05:00</published><updated>2020-08-14T00:00:00-05:00</updated><id>http://localhost:4000/Proyect-Software/jekyll/update/2020/08/14/Proceso-ing</id><content type="html" xml:base="http://localhost:4000/Proyect-Software/jekyll/update/2020/08/14/Proceso-ing.html">&lt;body style=&quot;background-color:#FFE5C7;font-family: Century Schoolbook&quot;&gt;
&lt;a name=&quot;tema2.1&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;FACTORES DE CALIDAD DE SOFTWARE.&lt;br&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt;
	Un software de calidad tiene concordancia con:&lt;br&gt;
	&lt;ul&gt;
		&lt;li&gt;Los &lt;b&gt; requisitos funcionales&lt;/b&gt; y de rendimiento &lt;b&gt;explícitamente &lt;/b &gt;establecidos.&lt;/li&gt;
		&lt;li&gt;Los &lt;b&gt; estándares&lt;/b&gt; de desarrollo explícitamente &lt;b&gt;documentados &lt;/b&gt; establecidos.&lt;/li&gt;
	&lt;/ul&gt;
	La clasificación de los factores de calidad se centra en tres aspectos importantes de un producto sofware.
	&lt;ol&gt;
		&lt;li&gt;Características operativas.&lt;/li&gt;
		&lt;li&gt;Capacidad de soportar cambios.&lt;/li&gt;
		&lt;li&gt;Adaptabilidad de nuevos entornos.&lt;/li&gt;
	&lt;/ol&gt;
	&lt;b&gt;1.- Características operativas&lt;/b&gt;&lt;br&gt;
	En esta característica señala que los factores para una calidad del software es que sean fiables, eficiente, corregible, tenga seguridad y de facil uso.&lt;br&gt;
	&lt;b&gt;2.- Capacidad de soportar cambios.&lt;/b&gt;&lt;br&gt;
	Un factor de calidad del software es que sean capaces de soportar cambios y para ello tiene que ser de facil mantenimiento, tiene que ser flexible y facilidad de prueba.&lt;br&gt;
	&lt;b&gt;3.- Adaptabilidad de nuevos entornos&lt;/b&gt;&lt;br&gt;
	Adaptabilidad de nuevos entornos como por ultima clasificación de los factores de calidad del softwate señala que un software de calidad debe ser portable, reusable y de facil interactuación con otro sistema.&lt;br&gt;
&lt;/p&gt;

&lt;br&gt;
&lt;a name=&quot;tema2.2&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;PROBLEMAS EN EL DESARROLLO DEL SOFTWARE&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt;Actualmente el software ha
superado al hardware como factor decisivo de éxito, ya que el software es el factor que marca la diferencia.&lt;br&gt;
El principal problema en el desarrollo del software es en resolver los problemas tradicionales.&lt;br&gt;
Los problemas tradicionales son la incapacidad para estimar tiempo, costo y esfuerzo para el desarrollo de un software, otro problema tradicional es la falta de calidad del producto software&lt;br&gt;
Otro problema al desarrollar un software es el avance del hardware ya que aumenta la necesidad de crear aplicaciones más complejas tomando en cuenta la relación entre el coste &lt;b&gt;Hardware/Software&lt;/b&gt;&lt;br&gt;
Otros problemas pueden ser:&lt;br&gt;
&lt;ul&gt;
	&lt;li&gt;Mala estimación del tiempo.&lt;/li&gt;
	&lt;li&gt;Mala administración de los riesgos.&lt;/li&gt;
	&lt;li&gt;Diseño no adecuado.&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;a name=&quot;tema2.3&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;hr size=5 style=&quot;background-color: lightseagreen&quot;&gt;
&lt;br&gt;
&lt;h1 align=&quot;center&quot;&gt;&lt;b&gt;RESPONSABILIDAD ETICA Y PROFESIONAL EN INGENIERIA DEL SOFTWARE&lt;/b&gt;&lt;/h1&gt;
&lt;p align=&quot;justify&quot;&gt;
	La ingeniería de software implica responsabilidades más amplias que simplemente la aplicación de habilidades técnicas.&lt;br&gt;Los ingenieros de software deben comportarse de una manera honesta y éticamente responsable para que puedan ser respetados como profesionales.&lt;br&gt;
&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Estándares de responsabilidad profesional&lt;br&gt;&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;b style=&quot;color: red&quot;&gt;Confidencialidad&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;Los ingenieros, tienen la obligación de respetar la confidencialidad de sus empleadores o clientes sin importar si se firmó o no un acuerdo formal sobre la misma. &lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: red&quot;&gt;Competencia&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;No debe desvirtuar su nivel de competencia. Es decir, no hay que aceptar de manera intencional trabajo que esté fuera de su competencia.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: red&quot;&gt;Derechos de propiedad intelectual&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;El ingeniero tiene que conocer las leyes locales que rigen el uso de la propiedad intelectual, como las patentes y el copyright.
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;Principios éticos.&lt;/b&gt;&lt;br&gt;&lt;/h4&gt;
&lt;center&gt;
	&lt;img src=&quot;/Proyect-Software/img/tema2/figura1.png&quot; height=&quot;150px&quot; align=&quot;auto&quot;&gt;&lt;br&gt;
	&lt;h5&gt;&lt;i&gt;&lt;u&gt;Figura 1: Ilustración de unos buenos principios éticos &lt;/u&gt;&lt;/i&gt;&lt;/h5&gt;
&lt;/center&gt;
&lt;ol&gt;
	&lt;li&gt;&lt;b style=&quot;color: #C13A2D&quot;&gt;Público&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;Los ingenieros de software deben actuar consecuentemente con el interés del público.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: #C13A2D&quot;&gt;Cliente y Empleador&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;Los ingenieros de software tienen que comportarse de tal forma que fomente el mejor interés para su cliente y empleador, en coherencia con el interés público.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: #C13A2D&quot;&gt;Producto&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;Los ingenieros de software deben garantizar que sus productos y modificaciones relacionadas satisfagan los estándares profesionales más altos posibles.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: #C13A2D&quot;&gt;Juicio&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;Los ingenieros de software tienen que mantener integridad e independencia en su juicio profesional.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: #C13A2D&quot;&gt;Gestión&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;Los administradores y líderes en la ingeniería de software deben promover un enfoque ético a la gestión del desarrollo y el mantenimiento del software.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: #C13A2D&quot;&gt;Profesión&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;Los ingenieros de software tienen que fomentar la integridad y la reputación de la profesión consecuente con el interés público.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: #C13A2D&quot;&gt;Colegas&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;Los ingenieros de software deben ser justos con sus colegas y apoyarlos.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;b style=&quot;color: #C13A2D&quot;&gt;Uno mismo&lt;/b&gt;
		&lt;p align=&quot;justify&quot;&gt;Los ingenieros de software tienen que intervenir en el aprendizaje para toda la vida, en cuanto a la práctica de su profesión, y promover un enfoque ético.&lt;/p&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;/body&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">FACTORES DE CALIDAD DE SOFTWARE. Un software de calidad tiene concordancia con: Los requisitos funcionales y de rendimiento explícitamente establecidos. Los estándares de desarrollo explícitamente documentados establecidos. La clasificación de los factores de calidad se centra en tres aspectos importantes de un producto sofware. Características operativas. Capacidad de soportar cambios. Adaptabilidad de nuevos entornos. 1.- Características operativas En esta característica señala que los factores para una calidad del software es que sean fiables, eficiente, corregible, tenga seguridad y de facil uso. 2.- Capacidad de soportar cambios. Un factor de calidad del software es que sean capaces de soportar cambios y para ello tiene que ser de facil mantenimiento, tiene que ser flexible y facilidad de prueba. 3.- Adaptabilidad de nuevos entornos Adaptabilidad de nuevos entornos como por ultima clasificación de los factores de calidad del softwate señala que un software de calidad debe ser portable, reusable y de facil interactuación con otro sistema.</summary></entry></feed>